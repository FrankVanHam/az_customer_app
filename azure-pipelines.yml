# trigger the pipeline on a push on the main branch
trigger:
- no_main

pool:
  vmImage: ubuntu-latest          # use an ubuntu image with java 17 installed

# set variables. Get the volatile one from the library group. The rest is set to point to directories for easy reading
variables:
  - group: customer-app-vars
  - name: CORE_DIR
    value: $(Pipeline.Workspace)/core

# ### Directory structure
# $(Pipeline.Workspace)/repo    contains the repository and become the working directory
# $(Pipeline.Workspace)/core    contains the core installation of Smallworld
# 
jobs:
- job: Compile
  steps:
    - task: JavaToolInstaller@1
      displayName: 'Activate java 17 sdk'
      inputs:
        versionSpec: '17' # string. Required. JDK version. Default: 8.
        jdkArchitectureOption: 'x64' #| 'x86' | 'arm64'. Required. JDK architecture. 
        jdkSourceOption: 'PreInstalled' # 'AzureStorage' | 'LocalDirectory' | 'PreInstalled'

    - checkout: self
      persistCredentials: true
      fetchDepth: 2 
      workspaceRepo: false
      path: repo

      # note this script runs in /repo
    - script: |
        git diff --name-only HEAD HEAD~1 > ../changed_files.txt
      displayName: 'Get changed files'

    - task: UniversalPackages@0
      displayName: 'Download the core application'
      inputs:
        command: download
        vstsFeed: 'SW/froggie'
        vstsFeedPackage: 'cst.jar'
        vstsPackageVersion: $(SW_VERSION)
        downloadDirectory: '$(CORE_DIR)'

    - script: |
        sudo java -Daccept_licences="YES" -Dinstall_language_packs="YES" -jar $(CORE_DIR)/core_installer.jar $(CORE_DIR) vsts vsts
      displayName: 'Install the core products'

    - task: PythonScript@0
      displayName: 'Detect products'
      name: detect_products
      inputs:
        scriptSource: 'filePath'
        scriptPath: scripts/detect_products.py
        arguments: ". 2 products_config"
        failOnStderr: true

    - script: |
        echo $(detect_products.products_config)
        echo '$(detect_products.products_config)' > products_config.json
      name: print_products
      displayName: "create a JSON file with products config"
      workingDirectory: $(Pipeline.Workspace)

    - task: PublishPipelineArtifact@1
      displayName: 'Publish products_config.json'
      inputs:
        targetPath: $(Pipeline.Workspace)/products_config.json
        artifact: $(System.JobAttempt)-products_config
        publishLocation: 'pipeline'
    
    - script: |
        $(CORE_DIR)/core/bin/share/runalias -j -Djava.awt.headless=true base -products_config $(Pipeline.Workspace)/products_config.json > compile.log
      displayName: 'Run the script $SW_MSF_STARTUP_MAGIK to compile and build'
      workingDirectory: $(Pipeline.Workspace)
      env:
        SW_MSF_STARTUP_MAGIK: $(Build.SourcesDirectory)/scripts/compile_and_build.magik
        CUSTOMER_APP_BASE_DIR: $(Build.SourcesDirectory)

    - task: PublishPipelineArtifact@1
      displayName: 'Publish compile log'
      inputs:
        targetPath: $(Pipeline.Workspace)/compile.log
        artifact: $(System.JobAttempt)-compile_log
        publishLocation: 'pipeline'

    - task: ArchiveFiles@2
      displayName: 'Archive the compiled product'
      inputs:
        rootFolderOrFile: $(Pipeline.Workspace)/repo
        archiveType: 'zip'
        archiveFile: $(Pipeline.Workspace)/repo.zip

    - task: PublishPipelineArtifact@1
      displayName: 'Publish compiled result (repo.zip) to be reused in the Archive job'
      inputs:
        targetPath: $(Pipeline.Workspace)/repo.zip
        artifact: $(System.JobAttempt)-repo_zip
        publishLocation: 'pipeline'

- job: Archive
  dependsOn: Compile
  strategy: 
    matrix: $[dependencies.Compile.outputs['detect_products.products_config']]
  # strategy provided variables $(product_name) and $(product_path)
  steps:
    - checkout: none

    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: $(System.JobAttempt)-repo_zip
      displayName: Download the repo.zip

    - task: ExtractFiles@1
      displayName: 'Extract repo.zip'
      inputs:
        archiveFilePatterns: '$(Pipeline.Workspace)/repo.zip'
        destinationFolder: '$(Pipeline.Workspace)/repo'

    - task: ArchiveFiles@2
      displayName: 'Archive $(product_path)'
      inputs:
        rootFolderOrFile: $(product_path)
        archiveType: 'zip'
        archiveFile: $(Build.ArtifactStagingDirectory)/$(product_name).zip

    - task: UniversalPackages@0
      displayName: 'Upload $(product_path)'
      inputs:
        command: publish
        vstsFeedPublish: 'SW/froggie'
        vstsFeedPackagePublish: $(product_name)-$(CUSTOMER_APP_VERSION).zip
        packagePublishDescription: Archive upload of product $(product_name) built for version $(CUSTOMER_APP_VERSION)
        publishDirectory: $(Build.ArtifactStagingDirectory)/$(product_name).zip