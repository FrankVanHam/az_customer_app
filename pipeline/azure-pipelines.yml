# trigger the pipeline on a push on the main branch
trigger:
- no_main

pool:
  vmImage: ubuntu-latest          # use an ubuntu image with java 17 installed

#### Directory structure
# $(Build.SourcesDirectory)           contains the repository and become the working directory
# $(Pipeline.Workspace)/core          contains the core installation of Smallworld
# $(Build.ArtifactStagingDirectory)   contains the zipfiles to be uploaded as artifacts
# $(Common.TestResultsDirectory)      contains the test results to be published
# 
# set variables. Get the volatile one from the library group. The rest is set to point to directories for easy reading
variables:
  - group: customer-app-vars
  - name: CORE_DIR
    value: $(Pipeline.Workspace)/core
  - name: EXTERNAL_DIR
    value: $(Pipeline.Workspace)/SW-external

parameters:
  - name: AZ_BUILD_ALL
    type: boolean
    default: false
  - name: AZ_BUILD_THIS
    type: string
    default: ''
  - name: AZ_DEBUG
    type: boolean
    default: false

jobs:
- job: Download
  steps:
  - script: |
      echo '${{parameters.AZ_BUILD_ALL}}'
      echo '${{parameters.AZ_BUILD_THIS}}'
  - template: azure-download.yml
    ## The step detect_products creates a variable products_config with the information about the changed products,
    ## which is then used in the Compile job to decide which products to compile. 
    ## The same variable is also passed to the Archive job to know which products to archive.

- job: Compile
  variables:
    products_config: $[ dependencies.Download.outputs['detect_products.products_config'] ]
    anything_changed: $[ ne(variables.products_config, '{}') ]
    need_compile: $[ contains(variables.products_config, 'layered_product') ]
  condition: eq(variables.anything_changed, 'true')
  dependsOn: Download
  steps:
    - template: azure-compile-and_archive.yml

- job: Archive
  dependsOn: [Download, Compile]
  strategy: 
    matrix: $[dependencies.Download.outputs['detect_products.products_config']]
  steps:
  - template: azure-package.yml