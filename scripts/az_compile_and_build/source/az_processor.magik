_package user
$

_pragma(classify_level=restricted)
##
## Object that kicks of the processing
##
def_slotted_exemplar(:az_processor,
	{})
$

_pragma(classify_level=restricted)
_method az_processor.compile_and_build()
	##
	_try
		_handling error _with _self.error_proc
		_self.int!compile_and_build()
	_when error 
		
	_endtry
	quit()
_endmethod
$

_pragma(classify_level=restricted)
_method az_processor.run_tests()
	##
	_local ok? << _false
	_try
		_handling error _with _self.error_proc
		ok? << _self.int!run_tests()
	_when error 
		
	_endtry
	quit(ok?)
_endmethod
$


_pragma(classify_level=restricted)
_method az_processor.int!compile_and_build()
	_self.correct_slashes_in_layer_products()
	
	_local config << _self.get_product_config_from_command_line()
	_if config.empty?
	_then
		write("No products to compile and build")
	_else
		bob.new().build(config)
	_endif 
_endmethod
$

_pragma(classify_level=restricted)
_method az_processor.int!run_tests()
	_self.correct_slashes_in_layer_products()
	_local output_dir << _self.get_output_dir_from_command_line()
	_local config << _self.get_product_config_from_command_line()
	_local aspects << _self.get_aspects_from_command_line()
	_if config.empty?
	_then
		write("No products to test")
		_return _true 
	_else
		_return az_test_runner.new().run(output_dir, config, aspects)
	_endif 
_endmethod
$

_pragma(classify_level=restricted)
_method az_processor.get_product_config_from_command_line()
	##
	_local file << _self.get_option("-products_config").default("")
	file << system.canonicalise(file)
	_if system.file_readable?(file).not
	_then
		condition.raise(:error, :string, write_string("The file ", file, " is not readable"))
	_endif
	_local config << simple_json_reader.new().read(file)

	# Filter out only the layered products
	_for key, props _over config.keys_and_elements()
	_loop
		_if props["product_type"].default("") <> "layered_product"
		_then
			config.remove_key(key)
		_endif 
	_endloop
	_return config 
_endmethod
$

_pragma(classify_level=restricted)
_method az_processor.get_output_dir_from_command_line()
	_local dir << _self.get_option("-test_output_dir").default("")
	dir << system.canonicalise(dir)
	_if system.file_exists?(dir).not
	_then
		condition.raise(:error, :string, write_string("The directory ", dir, " does not exist or the proces has no access to it."))
	_endif
	_return dir
_endmethod
$

_pragma(classify_level=restricted)
_method az_processor.get_aspects_from_command_line()
	##
	_local aspect_string << _self.get_option("-test_aspects").default("")
	_local aspect_keys << aspect_string.split_by(%,).map(_proc(x) >> x.trim_spaces().as_symbol() _endproc)
	_local aspects << property_list.new()
	_for key _over aspect_keys.fast_elements()
	_loop
		aspects[key] << write_string(key)
	_endloop
	_return aspects
_endmethod
$

_pragma(classify_level=restricted)
_method az_processor.get_option(p_key)
	##
	_local index << system.args.index_equal_of(p_key)
	_if index _is _unset
	_then
		_return _unset
	_elif index = system.args.size
	_then
		_return _unset
	_else
		_return system.args[index+1]
	_endif 
_endmethod
$

_pragma(classify_level=restricted)
_method az_processor.correct_slashes_in_layer_products()
	## Need this fix because loading products with backslashes
	## combined with forward slashes will fail on Ubuntu.
	##
	_for i_prop _over smallworld_product.layered_product_data().fast_elements()
	_loop
		_if system.os_name _is :windows
		_then
			i_prop[:path].substitute_character(%/, %\)
		_else
			i_prop[:path].substitute_character(%\, %/)
		_endif 
	_endloop 
_endmethod
$


_pragma(classify_level=restricted, topic={azure})
_method az_processor.error_proc
	## 
	_return _proc(p_condition)
			p_condition.report_contents_on(!output!)
			!traceback!(!output!)
		_endproc 
_endmethod
$
